"use strict";
/*
 * @adonisjs/mail
 *
 * (c) Harminder Virk <virk@adonisjs.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SparkPostTransport = void 0;
const got_1 = __importDefault(require("got"));
const get_stream_1 = __importDefault(require("get-stream"));
const utils_1 = require("../utils");
const EmailTransportException_1 = require("../Exceptions/EmailTransportException");
/**
 * Sparkpost transport for node mailer. Uses the `/message.mime` to send MIME
 * representation of the email
 */
class SparkPostTransport {
    constructor(config, logger) {
        this.config = config;
        this.logger = logger;
        this.name = 'sparkpost';
        this.version = '1.0.0';
    }
    /**
     * Returns base url for sending emails
     */
    getBaseUrl() {
        return this.config.baseUrl;
    }
    /**
     * Returns an array of recipients accepted by the SparkPost API
     */
    getRecipients(recipients) {
        return recipients.map((recipient) => {
            return {
                address: {
                    email: recipient.address,
                    ...(recipient.name ? { name: recipient.name } : {}),
                },
            };
        });
    }
    /**
     * Returns an object of options accepted by the sparkpost mail API
     */
    getOptions(config) {
        const options = new utils_1.ObjectBuilder();
        options.add('start_time', config.startTime);
        options.add('open_tracking', config.openTracking);
        options.add('click_tracking', config.clickTracking);
        options.add('transactional', config.transactional);
        options.add('sandbox', config.sandbox);
        options.add('skip_suppression', config.skipSuppression);
        options.add('ip_pool', config.ipPool);
    }
    /**
     * Send email
     */
    async send(mail, callback) {
        const url = `${this.getBaseUrl()}/transmissions`;
        const options = this.getOptions(this.config);
        const envelope = mail.message.getEnvelope();
        const addresses = (mail.data.to || []).concat(mail.data.cc || []).concat(mail.data.bcc || []);
        try {
            this.logger.trace({
                url,
                options,
            }, 'sparkpost email');
            /**
             * The sparkpost API doesn't accept the multipart stream and hence we
             * need to convert the stream to a buffer
             */
            const emailBody = await (0, get_stream_1.default)(mail.message.createReadStream());
            const response = await got_1.default.post(url, {
                json: {
                    recipients: this.getRecipients(addresses),
                    options: options,
                    content: {
                        email_rfc822: emailBody,
                    },
                },
                responseType: 'json',
                headers: {
                    Authorization: this.config.key,
                },
            });
            const messageId = (response.body.results?.id || mail.message.messageId()).replace(/^<|>$/g, '');
            callback(null, { messageId, envelope });
        }
        catch (error) {
            callback(EmailTransportException_1.EmailTransportException.apiFailure(error));
        }
    }
}
exports.SparkPostTransport = SparkPostTransport;
