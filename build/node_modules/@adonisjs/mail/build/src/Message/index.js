"use strict";
/*
 * @adonisjs/mail
 *
 * (c) Harminder Virk <virk@adonisjs.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Message = void 0;
const ical_generator_1 = __importDefault(require("ical-generator"));
/**
 * Fluent API to construct node mailer message object
 */
class Message {
    constructor(deferred = false) {
        this.deferred = deferred;
        this.nodeMailerMessage = {};
        /**
         * Path to the views used to generate content for the
         * message
         */
        this.contentViews = {};
    }
    /**
     * Returns address node with correctly formatted way
     */
    getAddress(address, name) {
        return name ? { address, name } : { address };
    }
    /**
     * Add receipent as `to`
     */
    to(address, name) {
        this.nodeMailerMessage.to = this.nodeMailerMessage.to || [];
        this.nodeMailerMessage.to.push(this.getAddress(address, name));
        return this;
    }
    /**
     * Add `from` name and email
     */
    from(address, name) {
        this.nodeMailerMessage.from = this.getAddress(address, name);
        return this;
    }
    /**
     * Add receipent as `cc`
     */
    cc(address, name) {
        this.nodeMailerMessage.cc = this.nodeMailerMessage.cc || [];
        this.nodeMailerMessage.cc.push(this.getAddress(address, name));
        return this;
    }
    /**
     * Add receipent as `bcc`
     */
    bcc(address, name) {
        this.nodeMailerMessage.bcc = this.nodeMailerMessage.bcc || [];
        this.nodeMailerMessage.bcc.push(this.getAddress(address, name));
        return this;
    }
    /**
     * Define custom message id
     */
    messageId(messageId) {
        this.nodeMailerMessage.messageId = messageId;
        return this;
    }
    /**
     * Define subject
     */
    subject(message) {
        this.nodeMailerMessage.subject = message;
        return this;
    }
    /**
     * Define replyTo email and name
     */
    replyTo(address, name) {
        this.nodeMailerMessage.replyTo = this.nodeMailerMessage.replyTo || [];
        this.nodeMailerMessage.replyTo.push(this.getAddress(address, name));
        return this;
    }
    /**
     * Define inReplyTo message id
     */
    inReplyTo(messageId) {
        this.nodeMailerMessage.inReplyTo = messageId;
        return this;
    }
    /**
     * Define multiple message id's as references
     */
    references(messagesIds) {
        this.nodeMailerMessage.references = messagesIds;
        return this;
    }
    /**
     * Optionally define email envolpe
     */
    envelope(envelope) {
        this.nodeMailerMessage.envelope = envelope;
        return this;
    }
    /**
     * Define contents encoding
     */
    encoding(encoding) {
        this.nodeMailerMessage.encoding = encoding;
        return this;
    }
    /**
     * Define email prority
     */
    priority(priority) {
        this.nodeMailerMessage.priority = priority;
        return this;
    }
    /**
     * Compute email html from defined view
     */
    htmlView(template, data) {
        this.contentViews.html = { template, data };
        return this;
    }
    /**
     * Compute email text from defined view
     */
    textView(template, data) {
        this.contentViews.text = { template, data };
        return this;
    }
    /**
     * Compute apple watch html from defined view
     */
    watchView(template, data) {
        this.contentViews.watch = { template, data };
        return this;
    }
    /**
     * Compute email html from raw text
     */
    html(content) {
        this.nodeMailerMessage.html = content;
        return this;
    }
    /**
     * Compute email text from raw text
     */
    text(content) {
        this.nodeMailerMessage.text = content;
        return this;
    }
    /**
     * Compute email watch html from raw text
     */
    watch(content) {
        this.nodeMailerMessage.watch = content;
        return this;
    }
    /**
     * Define one or attachments
     */
    attach(filePath, options) {
        this.nodeMailerMessage.attachments = this.nodeMailerMessage.attachments || [];
        this.nodeMailerMessage.attachments.push({
            path: filePath,
            ...options,
        });
        return this;
    }
    /**
     * Define attachment from raw data
     */
    attachData(content, options) {
        if (this.deferred) {
            throw new Error('Cannot attach raw data when using "Mail.sendLater" method');
        }
        this.nodeMailerMessage.attachments = this.nodeMailerMessage.attachments || [];
        this.nodeMailerMessage.attachments.push({
            content,
            ...options,
        });
        return this;
    }
    /**
     * Embed attachment inside content using `cid`
     */
    embed(filePath, cid, options) {
        this.nodeMailerMessage.attachments = this.nodeMailerMessage.attachments || [];
        this.nodeMailerMessage.attachments.push({
            path: filePath,
            cid,
            ...options,
        });
        return this;
    }
    /**
     * Embed attachment from raw data inside content using `cid`
     */
    embedData(content, cid, options) {
        if (this.deferred) {
            throw new Error('Cannot attach raw data when using "Mail.sendLater" method');
        }
        this.nodeMailerMessage.attachments = this.nodeMailerMessage.attachments || [];
        this.nodeMailerMessage.attachments.push({
            content,
            cid,
            ...options,
        });
        return this;
    }
    /**
     * Define custom headers for email
     */
    header(key, value) {
        this.nodeMailerMessage.headers = this.nodeMailerMessage.headers || [];
        this.nodeMailerMessage.headers.push({ [key]: value });
        return this;
    }
    /**
     * Define custom prepared headers for email
     */
    preparedHeader(key, value) {
        this.nodeMailerMessage.headers = this.nodeMailerMessage.headers || [];
        this.nodeMailerMessage.headers.push({ [key]: { prepared: true, value } });
        return this;
    }
    /**
     * Attach a calendar event and define contents as string
     */
    icalEvent(contents, options) {
        if (typeof contents === 'function') {
            const calendar = (0, ical_generator_1.default)();
            contents(calendar);
            contents = calendar.toString();
        }
        this.nodeMailerMessage.icalEvent = { content: contents, ...options };
        return this;
    }
    /**
     * Attach a calendar event and load contents from a file
     */
    icalEventFromFile(filePath, options) {
        this.nodeMailerMessage.icalEvent = { path: filePath, ...options };
        return this;
    }
    /**
     * Attach a calendar event and load contents from a url
     */
    icalEventFromUrl(url, options) {
        this.nodeMailerMessage.icalEvent = { href: url, ...options };
        return this;
    }
    /**
     * Get message JSON. The packet can be sent over to nodemailer
     */
    toJSON() {
        return {
            message: this.nodeMailerMessage,
            views: this.contentViews,
        };
    }
}
exports.Message = Message;
