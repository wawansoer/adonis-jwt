"use strict";
/*
 * @adonisjs/mail
 *
 * (c) Harminder Virk <virk@adonisjs.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MailManager = void 0;
/// <reference path="../../adonis-typings/mail.ts" />
const fastq_1 = __importDefault(require("fastq"));
const nodemailer_1 = __importDefault(require("nodemailer"));
const manager_1 = require("@poppinss/manager");
const utils_1 = require("@poppinss/utils");
const Mailer_1 = require("./Mailer");
const Fake_1 = require("../Fake");
const BaseMailer_1 = require("../BaseMailer");
const prettyPrint_1 = require("../Helpers/prettyPrint");
/**
 * The manager exposes the API to pull instance of [[Mailer]] class for pre-defined mappings
 * in the config file. The manager internally manages the state of mappings and cache
 * them for re-use.
 */
class MailManager extends manager_1.Manager {
    constructor(app, config) {
        super(app);
        this.app = app;
        this.config = config;
        /**
         * Emails queue to scheduling emails to be delivered later
         */
        this.emailsQueue = (0, fastq_1.default)(this, this.sendQueuedEmail, 10);
        /**
         * Method to monitor in-memory email queue
         */
        this.queueMonitor = (error) => {
            if (error) {
                this.logger.error({
                    subject: error.mail.message.subject,
                    message: error.message,
                }, 'Unable to deliver email');
            }
        };
        /**
         * Reference to the fake mailer manager
         */
        this.fakeMailManager = new Fake_1.FakeMailManager();
        /**
         * Caching driver instances. One must call `close` to clean it up
         */
        this.singleton = true;
        /**
         * Method to pretty print sent emails
         */
        this.prettyPrint = prettyPrint_1.prettyPrint;
        /**
         * Reference to the base mailer since Ioc container doesn't allow
         * multiple exports
         */
        this.BaseMailer = BaseMailer_1.BaseMailer;
        /**
         * Dependencies from the "@adonisjs/core" and "@adonisjs/view". The manager classes
         * in AdonisJS codebase heavily relies on the container and hence we can pull
         * container bindings directly here.
         */
        this.view = this.app.container.hasBinding('Adonis/Core/View')
            ? this.app.container.use('Adonis/Core/View')
            : undefined;
        this.emitter = this.app.container.use('Adonis/Core/Event');
        this.logger = this.app.container.use('Adonis/Core/Logger');
        this.profiler = this.app.container.use('Adonis/Core/Profiler');
        this.BaseMailer.mail = this;
        this.validateConfig();
    }
    /**
     * Validate config at runtime
     */
    validateConfig() {
        const validator = new utils_1.ManagerConfigValidator(this.config, 'mail', 'config/mail');
        validator.validateDefault('mailer');
        validator.validateList('mailers', 'mailer');
    }
    /**
     * Sends the email by pulling it from the queue. This method is invoked
     * automatically by fastq.
     */
    async sendQueuedEmail(mail, cb) {
        try {
            const response = await this.use(mail.mailer).sendCompiled(mail);
            cb(null, { mail, response });
        }
        catch (error) {
            error.mail = mail;
            cb(error);
        }
    }
    /**
     * Creates and returns an ethereal email account. Node mailer internally
     * ensures only a single email account is created and hence we don't
     * have to worry about caching credentials.
     */
    getEtherealAccount() {
        return new Promise((resolve, reject) => {
            nodemailer_1.default.createTestAccount((error, account) => {
                if (error) {
                    reject(error);
                }
                else {
                    resolve(account);
                }
            });
        });
    }
    /**
     * Since we don't expose the drivers instances directly, we wrap them
     * inside the mailer instance.
     */
    wrapDriverResponse(mappingName, driver) {
        return new Mailer_1.Mailer(mappingName, this, true, driver);
    }
    /**
     * Returns the driver name for a given mapping
     */
    getMappingDriver(name) {
        const config = this.getMappingConfig(name);
        return config && config.driver;
    }
    /**
     * Returns the config for a given mapping
     */
    getMappingConfig(name) {
        return this.config.mailers[name];
    }
    /**
     * Returns the name of the default mapping
     */
    getDefaultMappingName() {
        return this.config.mailer;
    }
    /**
     * Creates an instance of `smtp` driver by lazy loading. This method
     * is invoked internally when a new driver instance is required
     */
    createSmtp(_, config) {
        const { SmtpDriver } = require('../Drivers/Smtp');
        return new SmtpDriver(config);
    }
    /**
     * Creates an instance of `ses` driver by lazy loading. This method
     * is invoked internally when a new driver instance is required
     */
    createSes(_, config) {
        const { SesDriver } = require('../Drivers/Ses');
        return new SesDriver(config);
    }
    /**
     * Creates an instance of `mailgun` driver by lazy loading. This method
     * is invoked internally when a new driver instance is required
     */
    createMailgun(_, config) {
        const { MailgunDriver } = require('../Drivers/Mailgun');
        return new MailgunDriver(config, this.logger);
    }
    /**
     * Creates an instance of `sparkpost` driver by lazy loading. This method
     * is invoked internally when a new driver instance is required
     */
    createSparkpost(_, config) {
        const { SparkPostDriver } = require('../Drivers/SparkPost');
        return new SparkPostDriver(config, this.logger);
    }
    /**
     * Method to schedule email for sending. This method is invoked by
     * the mailer when `sendLater` method is called
     */
    scheduleEmail(mail) {
        this.emailsQueue.push(mail, this.queueMonitor);
    }
    /**
     * Fake one or more mailers. Calling the method multiple times
     * appends to the list of faked mailers
     */
    fake(mailers) {
        mailers = mailers || this.getDefaultMappingName();
        const mailersToFake = Array.isArray(mailers) ? mailers : [mailers];
        const { FakeDriver } = require('../Drivers/Fake');
        mailersToFake.forEach((mailer) => {
            this.fakeMailManager.fakedMailers.set(mailer, new Mailer_1.Mailer('fake', this, false, new FakeDriver()));
        });
        return this.fakeMailManager;
    }
    /**
     * Define a callback to monitor emails queue
     */
    monitorQueue(callback) {
        this.queueMonitor = callback;
    }
    /**
     * Restore fakes
     */
    restore(mailers) {
        mailers = mailers || this.getDefaultMappingName();
        const mailersToRestore = Array.isArray(mailers) ? mailers : [mailers];
        mailersToRestore.forEach((mailer) => {
            this.fakeMailManager.restore(mailer);
        });
    }
    /**
     * Sends email using the default `mailer`
     */
    async send(callback) {
        /**
         * Use fake and return its response
         */
        if (this.fakeMailManager.isFaked(this.getDefaultMappingName())) {
            return this.fakeMailManager.use(this.getDefaultMappingName()).send(callback);
        }
        return this.use().send(callback);
    }
    /**
     * Send email by pushing it to the in-memory queue
     */
    async sendLater(callback) {
        /**
         * Use fake and return its response
         */
        if (this.fakeMailManager.isFaked(this.getDefaultMappingName())) {
            return this.fakeMailManager.use(this.getDefaultMappingName()).send(callback);
        }
        return this.use().sendLater(callback);
    }
    /**
     * Use a named or the default mailer
     */
    use(name) {
        name = name || this.getDefaultMappingName();
        /**
         * Use fake
         */
        if (this.fakeMailManager.isFaked(name)) {
            return this.fakeMailManager.use(name);
        }
        return super.use(name);
    }
    /**
     * Closes the mapping instance and removes it from the cache
     */
    async close(name) {
        const mailer = name ? this.use(name) : this.use();
        await mailer.close();
    }
    /**
     * Closes the mapping instance and removes it from the cache
     */
    async closeAll() {
        await Promise.all(Array.from(this['mappingsCache'].keys()).map((name) => this.close(name)));
    }
    /**
     * Sends email to the ethereal email account. This is great
     * for previewing emails
     */
    async preview(callback) {
        const account = await this.getEtherealAccount();
        const mappingName = 'ethereal';
        const smtpDriver = this.createSmtp(mappingName, {
            host: account.smtp.host,
            port: account.smtp.port,
            secure: account.smtp.secure,
            auth: {
                user: account.user,
                pass: account.pass,
            },
        });
        const mailer = this.wrapDriverResponse(mappingName, smtpDriver);
        const response = await mailer.send(callback);
        return {
            ...response,
            url: nodemailer_1.default.getTestMessageUrl(response),
            account: {
                user: account.user,
                pass: account.pass,
            },
        };
    }
}
exports.MailManager = MailManager;
