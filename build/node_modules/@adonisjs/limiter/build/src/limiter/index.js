"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Limiter = void 0;
const helpers_1 = require("@poppinss/utils/build/helpers");
const throttle_exception_1 = require("../exceptions/throttle_exception");
class Limiter {
    rateLimiter;
    constructor(rateLimiter) {
        this.rateLimiter = rateLimiter;
    }
    timeToSeconds(duration) {
        return helpers_1.string.toMs(duration) / 1000;
    }
    async consume(key) {
        try {
            const response = await this.rateLimiter.consume(key, 1);
            return {
                remaining: response.remainingPoints,
                limit: this.rateLimiter.points,
                consumed: response.consumedPoints,
                retryAfter: response.msBeforeNext,
            };
        }
        catch (errorResponse) {
            if (errorResponse.consumedPoints) {
                throw throttle_exception_1.ThrottleException.invoke({
                    remaining: errorResponse.remainingPoints,
                    limit: this.rateLimiter.points,
                    consumed: errorResponse.consumedPoints,
                    retryAfter: errorResponse.msBeforeNext,
                });
            }
            else {
                throw errorResponse;
            }
        }
    }
    async increment(key) {
        try {
            await this.consume(key);
        }
        catch (error) {
            if (error instanceof throttle_exception_1.ThrottleException === false) {
                throw error;
            }
        }
    }
    async get(key) {
        const response = await this.rateLimiter.get(key);
        if (!response || Number.isNaN(response.remainingPoints)) {
            return null;
        }
        return {
            remaining: response.remainingPoints,
            limit: this.rateLimiter.points,
            consumed: response.consumedPoints,
            retryAfter: response.msBeforeNext,
        };
    }
    async remaining(key) {
        const response = await this.get(key);
        if (!response) {
            return this.rateLimiter.points;
        }
        return response.remaining;
    }
    async isBlocked(key) {
        const response = await this.get(key);
        if (!response) {
            return false;
        }
        return response.consumed > response.limit;
    }
    delete(key) {
        return this.rateLimiter.delete(key);
    }
    block(key, duration) {
        return this.rateLimiter.block(key, this.timeToSeconds(duration));
    }
    set(key, requests, duration) {
        return this.rateLimiter.set(key, requests, this.timeToSeconds(duration));
    }
}
exports.Limiter = Limiter;
