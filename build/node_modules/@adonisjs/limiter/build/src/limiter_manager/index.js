"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LimiterManager = void 0;
const helpers_1 = require("@poppinss/utils/build/helpers");
const rate_limiter_flexible_1 = require("rate-limiter-flexible");
const limiter_1 = require("../limiter");
const config_builder_1 = require("../config_builder");
const unsupported_db_exception_1 = require("../exceptions/unsupported_db_exception");
const invalid_client_exception_1 = require("../exceptions/invalid_client_exception");
const unrecognized_store_exception_1 = require("../exceptions/unrecognized_store_exception");
class LimiterManager {
    application;
    config;
    httpLimiters;
    limiters = new Map();
    constructor(application, config, httpLimiters) {
        this.application = application;
        this.config = config;
        this.httpLimiters = httpLimiters;
    }
    timeToSeconds(duration) {
        return duration ? helpers_1.string.toMs(duration) / 1000 : undefined;
    }
    makeStoreKey(store, config) {
        return [
            `s:${store}`,
            `r:${config.requests}`,
            `d:${this.timeToSeconds(config.duration)}`,
            ...(config.blockDuration ? [`bd:${this.timeToSeconds(config.blockDuration)}`] : []),
        ].join(',');
    }
    createRedis(storeConfig, config) {
        const { ioConnection } = this.application.container
            .resolveBinding('Adonis/Addons/Redis')
            .connection(storeConfig.connectionName);
        return new rate_limiter_flexible_1.RateLimiterRedis({
            storeClient: ioConnection,
            points: config.requests,
            keyPrefix: storeConfig.keyPrefix,
            duration: this.timeToSeconds(config.duration),
            blockDuration: this.timeToSeconds(config.blockDuration),
            inmemoryBlockDuration: this.timeToSeconds(storeConfig.inmemoryBlockDuration),
            inmemoryBlockOnConsumed: this.timeToSeconds(storeConfig.inmemoryBlockOnConsumed),
        });
    }
    createDatabase(storeConfig, config) {
        const Database = this.application.container.resolveBinding('Adonis/Lucid/Database');
        const connection = Database.connection(storeConfig.connectionName);
        const dbConfig = {
            storeType: 'knex',
            tableCreated: true,
            points: config.requests,
            dbName: storeConfig.dbName,
            tableName: storeConfig.tableName,
            keyPrefix: storeConfig.keyPrefix,
            storeClient: connection.getWriteClient(),
            duration: this.timeToSeconds(config.duration),
            clearExpiredByTimeout: storeConfig.clearExpiredByTimeout,
            blockDuration: this.timeToSeconds(config.blockDuration),
            inmemoryBlockDuration: this.timeToSeconds(storeConfig.inmemoryBlockDuration),
            inmemoryBlockOnConsumed: this.timeToSeconds(storeConfig.inmemoryBlockOnConsumed),
        };
        switch (connection.dialect.name) {
            case 'mysql':
                return new rate_limiter_flexible_1.RateLimiterMySQL(dbConfig);
            case 'postgres':
                return new rate_limiter_flexible_1.RateLimiterPostgres(dbConfig);
            default:
                throw unsupported_db_exception_1.UnsupportedDbException.invoke(connection.dialect.name);
        }
    }
    createLimiter(store, config) {
        const storeConfig = this.config.stores[store];
        if (!storeConfig) {
            throw unrecognized_store_exception_1.UnrecognizedStoreException.invoke(store);
        }
        switch (storeConfig.client) {
            case 'redis':
                return new limiter_1.Limiter(this.createRedis(storeConfig, config));
            case 'db':
                return new limiter_1.Limiter(this.createDatabase(storeConfig, config));
            default:
                throw invalid_client_exception_1.InvalidClientException.invoke(storeConfig.client);
        }
    }
    use(store, config) {
        if (!config) {
            config = store;
            store = this.config.default;
        }
        const storeKey = this.makeStoreKey(store, config);
        if (this.limiters.has(storeKey)) {
            return this.limiters.get(storeKey);
        }
        const limiter = this.createLimiter(store, config);
        this.limiters.set(storeKey, limiter);
        return limiter;
    }
    define(name, callback) {
        ;
        this.httpLimiters[name] = callback;
        return this;
    }
    allowRequests(request) {
        return new config_builder_1.HttpLimiterConfigBuilder().allowRequests(request);
    }
    noLimit() {
        return null;
    }
}
exports.LimiterManager = LimiterManager;
